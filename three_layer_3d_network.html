<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>三层 3D 网络 · 结构→生态→徽章（Three.js Demo）</title>
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;600;700&display=swap" rel="stylesheet">
<style>
  :root{--bg1:#0b1020;--bg2:#0e1430;--ink:#e7ecff;--muted:#98a1c0;--line:#1c2447;--blue:#6c8cff;--green:#34d399;--amber:#f59e0b;}
  *{box-sizing:border-box}html,body{margin:0;height:100%;background:linear-gradient(180deg,var(--bg1),var(--bg2));color:var(--ink);font-family:'Noto Sans SC',system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;overflow:hidden}
  .hud{position:fixed;left:12px;top:12px;display:flex;gap:8px;align-items:center;background:rgba(18,24,51,.6);border:1px solid #2a3b7a;color:#dbe6ff;border-radius:12px;padding:8px 10px;backdrop-filter: blur(6px)}
  .hud label{font-size:12px;color:#c9d4ff;margin-right:8px}
  .chip{display:inline-flex;align-items:center;gap:6px;padding:2px 8px;border:1px solid #2a3b7a;border-radius:999px;font-size:11px;color:#cfe0ff;background:rgba(90,118,221,.12)}
  .legend{position:fixed;left:12px;bottom:12px;display:flex;gap:8px;flex-wrap:wrap}
  .tooltip{position:fixed;pointer-events:none;transform:translate(-50%,-140%);background:rgba(15,23,51,.9);border:1px solid #2a3b7a;color:#eaf2ff;padding:6px 8px;border-radius:8px;font-size:12px;opacity:0;transition:opacity .15s}
  canvas{display:block}
</style>
</head>
<body>
<div class="hud">
  <label><input id="autoRotate" type="checkbox" checked> 自动旋转</label>
  <label><input id="showLinks" type="checkbox" checked> 显示连线</label>
  <span class="chip">内层：结构 8</span>
  <span class="chip">中层：生态 16</span>
  <span class="chip">外层：生态徽章 16</span>
</div>
<div class="legend">
  <span class="chip">结构→生态：蓝线</span>
  <span class="chip">生态→徽章：绿线</span>
</div>
<div id="tooltip" class="tooltip"></div>

<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
import { OrbitControls } from "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js";

// ===== 数据：名称与锚位 =====
const STRUCT8 = ["镜面","筋骨","水流","火焰","指南针","盾牌","桥梁","岩石"];
const ECO16 = [
  "信任速度","协作质量","关系韧性","影响半径","目标推进力","节奏管理",
  "应变效率","落地闭环度","洞察敏锐度","表达条理度","信息整合度","改进驱动力",
  "能量外放","冲突风格","环境贴合度","幸福感基础"
];
// 结构8锚到16轴索引（与你的系统一致）
const STRUCT_ANCHORS = [8,7,6,12,4,15,1,0];
const STRUCT_ANCHOR_INV = {}; STRUCT_ANCHORS.forEach((ecoIdx,k)=>STRUCT_ANCHOR_INV[ecoIdx]=k);

// ===== 场景、相机、渲染器 =====
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x0b1020, 0.0025);

const camera = new THREE.PerspectiveCamera(55, window.innerWidth/window.innerHeight, 0.1, 2000);
camera.position.set(0, 140, 420);

const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setClearColor(0x0b1020, 1);
document.body.appendChild(renderer.domElement);

// 轻微环境光 + 定向光，给球体一点层次
scene.add(new THREE.AmbientLight(0x8899ff, 0.8));
const dir = new THREE.DirectionalLight(0xffffff, 0.6); dir.position.set(1,1,1); scene.add(dir);

// 轨道控制
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.autoRotate = true;
controls.autoRotateSpeed = 0.5;

// ===== 背景星点
const starGeo = new THREE.BufferGeometry();
const starCount = 600;
const starPositions = new Float32Array(starCount*3);
for(let i=0;i<starCount;i++){
  const r = 900 + Math.random()*400;
  const theta = Math.random()*Math.PI*2;
  const phi = Math.acos(2*Math.random()-1);
  const x = r*Math.sin(phi)*Math.cos(theta);
  const y = r*Math.cos(phi);
  const z = r*Math.sin(phi)*Math.sin(theta);
  starPositions.set([x,y,z], i*3);
}
starGeo.setAttribute('position', new THREE.BufferAttribute(starPositions,3));
const starMat = new THREE.PointsMaterial({ size: 2, color: 0x28407a, transparent:true, opacity:0.6 });
const stars = new THREE.Points(starGeo, starMat);
scene.add(stars);

// ===== 三层半径
let R_STRUCT = 110, R_ECO = 170, R_BADGE = 220;

// 均匀分布：Fibonacci 球面
function fibonacciSphere(n, radius, seedRot=0){
  const pts = [];
  const offset = 2 / n;
  const inc = Math.PI * (3 - Math.sqrt(5));
  for(let i=0;i<n;i++){
    const y = ((i * offset) - 1) + (offset / 2);
    const r = Math.sqrt(1 - y*y);
    const phi = (i + seedRot) * inc;
    const x = Math.cos(phi) * r;
    const z = Math.sin(phi) * r;
    pts.push(new THREE.Vector3(x*radius, y*radius, z*radius));
  }
  return pts;
}

// 我们希望 16 轴均匀环绕，因此用 Fibonacci 生成 16 个生态位；结构用其锚位；徽章用相同角度外扩
const ecoPositions = fibonacciSphere(16, R_ECO, 0);
const structPositions = ecoPositions.map((p,i)=>{
  if(STRUCT_ANCHOR_INV[i] != null){
    const v = p.clone().normalize().multiplyScalar(R_STRUCT);
    return v;
  }
  return null;
});
const badgePositions = ecoPositions.map(p=> p.clone().normalize().multiplyScalar(R_BADGE));

// ===== 节点材质（带发光色）
function makeNode(color, emissive){
  return new THREE.MeshPhongMaterial({ color, emissive, shininess: 50, specular: 0x3355aa });
}
const matStruct = makeNode(0x94b0ff, 0x1d2f6b);
const matEco    = makeNode(0x34d399, 0x104d3d);
const matBadge  = makeNode(0xeaf2ff, 0x2a396b);

// 节点集合，记录 axis/name/type/mesh
const nodes = [];
const edges = []; // 保存线段对象，便于高亮

// 几何缓存
const geoStruct = new THREE.SphereGeometry(4.2, 24, 24);
const geoEco    = new THREE.SphereGeometry(3.6, 24, 24);
const geoBadge  = new THREE.SphereGeometry(3.4, 24, 24);

// 结构节点（8）
for(let i=0;i<16;i++){
  const pos = structPositions[i];
  if(!pos) continue;
  const k8 = STRUCT_ANCHOR_INV[i];
  const mesh = new THREE.Mesh(geoStruct, matStruct.clone());
  mesh.position.copy(pos);
  mesh.userData = { axis:i, type:'struct', name: STRUCT8[k8] };
  scene.add(mesh);
  nodes.push(mesh);
}
// 生态节点（16）
for(let i=0;i<16;i++){
  const mesh = new THREE.Mesh(geoEco, matEco.clone());
  mesh.position.copy(ecoPositions[i]);
  mesh.userData = { axis:i, type:'eco', name: ECO16[i] };
  scene.add(mesh);
  nodes.push(mesh);
}
// 徽章节点（16）
for(let i=0;i<16;i++){
  const mesh = new THREE.Mesh(geoBadge, matBadge.clone());
  mesh.position.copy(badgePositions[i]);
  mesh.userData = { axis:i, type:'badge', name: ECO16[i] + "·徽章" };
  scene.add(mesh);
  nodes.push(mesh);
}

// ===== 连线（Line2 的粗线跨平台性一般，这里用普通 LineBasicMaterial + 颜色高亮）
function makeLink(p1, p2, colorHex){
  const geo = new THREE.BufferGeometry().setFromPoints([p1, p2]);
  const mat = new THREE.LineBasicMaterial({ color: colorHex, transparent:true, opacity: 0.5 });
  const line = new THREE.Line(geo, mat);
  return line;
}

// 结构→生态（蓝线）
for(let i=0;i<16;i++){
  const sp = structPositions[i];
  if(!sp) continue;
  const ep = ecoPositions[i];
  const line = makeLink(sp, ep, 0x6c8cff);
  line.userData = { axis:i, kind:'SE' };
  scene.add(line);
  edges.push(line);
}
// 生态→徽章（绿线）
for(let i=0;i<16;i++){
  const ep = ecoPositions[i];
  const bp = badgePositions[i];
  const line = makeLink(ep, bp, 0x34d399);
  line.userData = { axis:i, kind:'EB' };
  scene.add(line);
  edges.push(line);
}

// ===== 背景球体（隐约网格，突出层级感）
const gridGeo = new THREE.SphereGeometry(R_BADGE+6, 32, 32);
const gridMat = new THREE.MeshBasicMaterial({ color:0x233066, wireframe:true, transparent:true, opacity:0.08 });
const gridMesh = new THREE.Mesh(gridGeo, gridMat);
scene.add(gridMesh);

// ===== 交互：射线拾取 + 高亮路径 + 提示
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
const tooltip = document.getElementById('tooltip');

function setTooltip(x, y, text){
  tooltip.style.left = x + "px";
  tooltip.style.top = y + "px";
  tooltip.textContent = text;
  tooltip.style.opacity = 1;
}
function hideTooltip(){ tooltip.style.opacity = 0; }

let lastAxisHighlighted = null;
function highlightAxis(axis, on){
  edges.forEach(line => {
    if(line.userData.axis === axis){
      const m = line.material;
      if(line.userData.kind === 'SE'){
        m.color.set(on ? 0x9db4ff : 0x6c8cff);
        m.opacity = on ? 1.0 : 0.5;
      }else{
        m.color.set(on ? 0x62e0b6 : 0x34d399);
        m.opacity = on ? 1.0 : 0.5;
      }
    }else if(on){
      // 降低其他线条
      line.material.opacity = 0.12;
    }else{
      // 还原
      line.material.opacity = 0.5;
    }
  });
  nodes.forEach(n => {
    if(n.userData.axis === axis){
      n.scale.set(1.35,1.35,1.35);
      if(n.material.emissive) n.material.emissiveIntensity = 0.9;
    }else{
      n.scale.set(1,1,1);
      if(n.material.emissive) n.material.emissiveIntensity = 0.4;
    }
  });
  lastAxisHighlighted = on ? axis : null;
}

function onPointerMove(ev){
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((ev.clientY - rect.top) / rect.height) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(nodes, false);
  if(intersects.length){
    const obj = intersects[0].object;
    highlightAxis(obj.userData.axis, true);
    setTooltip(ev.clientX, ev.clientY, `${obj.userData.type} · ${obj.userData.name}`);
  }else{
    highlightAxis(lastAxisHighlighted, false);
    hideTooltip();
  }
}
renderer.domElement.addEventListener('pointermove', onPointerMove);

// 点击锁定/解锁高亮
let lockedAxis = null;
renderer.domElement.addEventListener('click', (ev)=>{
  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((ev.clientY - rect.top) / rect.height) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(nodes, false);
  if(intersects.length){
    const obj = intersects[0].object;
    lockedAxis = (lockedAxis===obj.userData.axis) ? null : obj.userData.axis;
    highlightAxis(lockedAxis, !!lockedAxis);
  }else{
    lockedAxis = null;
    highlightAxis(lastAxisHighlighted, false);
  }
});

// HUD 开关
document.getElementById('autoRotate').addEventListener('change', (e)=>{
  controls.autoRotate = e.target.checked;
});
document.getElementById('showLinks').addEventListener('change', (e)=>{
  const vis = e.target.checked;
  edges.forEach(line => line.visible = vis);
});

// 自适应
window.addEventListener('resize', ()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// 轻微呼吸动画
function pulseNodes(t){
  const s = 1 + Math.sin(t*1.6)*0.03;
  nodes.forEach(n => {
    if(lockedAxis!=null && n.userData.axis!==lockedAxis) return; // 锁定时只呼吸选中轴
    n.scale.setScalar(s);
  });
}

// 主循环
const clock = new THREE.Clock();
function animate(){
  const t = clock.getElapsedTime();
  controls.update();
  stars.rotation.y += 0.0006;
  gridMesh.rotation.y += 0.0004;
  pulseNodes(t);
  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}
animate();

</script>
</body>
</html>
