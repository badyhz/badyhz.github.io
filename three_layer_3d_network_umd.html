<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>三层 3D 网络 · 结构→生态→徽章（Three.js UMD 本地版）</title>
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;600;700&display=swap" rel="stylesheet">
<style>
  :root{--bg1:#0b1020;--bg2:#0e1430;--ink:#e7ecff;--muted:#98a1c0;--line:#1c2447;}
  *{box-sizing:border-box}html,body{margin:0;height:100%;background:linear-gradient(180deg,var(--bg1),var(--bg2));color:var(--ink);font-family:'Noto Sans SC',system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;overflow:hidden}
  .hud{position:fixed;left:12px;top:12px;display:flex;gap:8px;align-items:center;background:rgba(18,24,51,.6);border:1px solid #2a3b7a;color:#dbe6ff;border-radius:12px;padding:8px 10px;backdrop-filter: blur(6px); z-index:10}
  .hud label{font-size:12px;color:#c9d4ff;margin-right:8px}
  .chip{display:inline-flex;align-items:center;gap:6px;padding:2px 8px;border:1px solid #2a3b7a;border-radius:999px;font-size:11px;color:#cfe0ff;background:rgba(90,118,221,.12)}
  .legend{position:fixed;left:12px;bottom:12px;display:flex;gap:8px;flex-wrap:wrap; z-index:10}
  .tooltip{position:fixed;pointer-events:none;transform:translate(-50%,-140%);background:rgba(15,23,51,.9);border:1px solid #2a3b7a;color:#eaf2ff;padding:6px 8px;border-radius:8px;font-size:12px;opacity:0;transition:opacity .15s; z-index:10}
  #fallback{position:fixed;inset:0;display:none;align-items:center;justify-content:center;color:#eaf2ff;background:rgba(10,16,40,.9);font-size:14px;padding:16px;text-align:center;z-index:20}
  canvas{display:block}
</style>
</head>
<body>
<div class="hud">
  <label><input id="autoRotate" type="checkbox" checked> 自动旋转</label>
  <label><input id="showLinks" type="checkbox" checked> 显示连线</label>
  <span class="chip">内层：结构 8</span>
  <span class="chip">中层：生态 16</span>
  <span class="chip">外层：生态徽章 16</span>
</div>
<div class="legend">
  <span class="chip">结构→生态：蓝线</span>
  <span class="chip">生态→徽章：绿线</span>
</div>
<div id="tooltip" class="tooltip"></div>
<div id="fallback">⚠️ 您的浏览器似乎未启用 WebGL 或三维加速。<br/>请在 Chrome 地址栏输入 <code>chrome://settings/system</code>，开启“使用硬件加速”，并重启浏览器；或更新显卡驱动。<br/>也可尝试在地址栏输入 <code>chrome://flags</code>，将 WebGL 相关选项设为 Enabled。</div>

<!-- UMD 构建（非模块），避免本地 file:// 下的 CORS/ESM 限制 -->
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.js"></script>

<script>
(function(){
  // WebGL 支持检测
  try{
    const canvas = document.createElement('canvas');
    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    if(!gl) throw new Error('no webgl');
  }catch(e){
    document.getElementById('fallback').style.display = 'flex';
    return;
  }

  const STRUCT8 = ["镜面","筋骨","水流","火焰","指南针","盾牌","桥梁","岩石"];
  const ECO16 = [
    "信任速度","协作质量","关系韧性","影响半径","目标推进力","节奏管理",
    "应变效率","落地闭环度","洞察敏锐度","表达条理度","信息整合度","改进驱动力",
    "能量外放","冲突风格","环境贴合度","幸福感基础"
  ];
  const STRUCT_ANCHORS = [8,7,6,12,4,15,1,0];
  const STRUCT_ANCHOR_INV = {}; STRUCT_ANCHORS.forEach((ecoIdx,k)=>STRUCT_ANCHOR_INV[ecoIdx]=k);

  const scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x0b1020, 0.0025);

  const camera = new THREE.PerspectiveCamera(55, window.innerWidth/window.innerHeight, 0.1, 2000);
  camera.position.set(0, 140, 420);

  const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setClearColor(0x0b1020, 1);
  document.body.appendChild(renderer.domElement);

  scene.add(new THREE.AmbientLight(0x8899ff, 0.8));
  const dir = new THREE.DirectionalLight(0xffffff, 0.6); dir.position.set(1,1,1); scene.add(dir);

  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.autoRotate = true;
  controls.autoRotateSpeed = 0.5;

  // 背景星点
  const starGeo = new THREE.BufferGeometry();
  const starCount = 600;
  const starPositions = new Float32Array(starCount*3);
  for(let i=0;i<starCount;i++){
    const r = 900 + Math.random()*400;
    const theta = Math.random()*Math.PI*2;
    const phi = Math.acos(2*Math.random()-1);
    const x = r*Math.sin(phi)*Math.cos(theta);
    const y = r*Math.cos(phi);
    const z = r*Math.sin(phi)*Math.sin(theta);
    starPositions.set([x,y,z], i*3);
  }
  starGeo.setAttribute('position', new THREE.BufferAttribute(starPositions,3));
  const starMat = new THREE.PointsMaterial({ size: 2, color: 0x28407a, transparent:true, opacity:0.6 });
  const stars = new THREE.Points(starGeo, starMat); scene.add(stars);

  // 半径
  let R_STRUCT = 110, R_ECO = 170, R_BADGE = 220;

  function fibonacciSphere(n, radius, seedRot=0){
    const pts = [];
    const offset = 2 / n;
    const inc = Math.PI * (3 - Math.sqrt(5));
    for(let i=0;i<n;i++){
      const y = ((i * offset) - 1) + (offset / 2);
      const r = Math.sqrt(1 - y*y);
      const phi = (i + seedRot) * inc;
      const x = Math.cos(phi) * r;
      const z = Math.sin(phi) * r;
      pts.push(new THREE.Vector3(x*radius, y*radius, z*radius));
    }
    return pts;
  }

  const ecoPositions = fibonacciSphere(16, R_ECO, 0);
  const structPositions = ecoPositions.map((p,i)=> STRUCT_ANCHOR_INV[i] != null ? p.clone().normalize().multiplyScalar(R_STRUCT) : null);
  const badgePositions  = ecoPositions.map(p => p.clone().normalize().multiplyScalar(R_BADGE));

  function makeNode(color, emissive){
    return new THREE.MeshPhongMaterial({ color, emissive, shininess: 50, specular: 0x3355aa, emissiveIntensity:0.4 });
  }
  const matStruct = makeNode(0x94b0ff, 0x1d2f6b);
  const matEco    = makeNode(0x34d399, 0x104d3d);
  const matBadge  = makeNode(0xeaf2ff, 0x2a396b);

  const nodes = [];
  const edges = [];
  const geoStruct = new THREE.SphereGeometry(4.2, 24, 24);
  const geoEco    = new THREE.SphereGeometry(3.6, 24, 24);
  const geoBadge  = new THREE.SphereGeometry(3.4, 24, 24);

  for(let i=0;i<16;i++){
    const pos = structPositions[i];
    if(!pos) continue;
    const k8 = STRUCT_ANCHOR_INV[i];
    const mesh = new THREE.Mesh(geoStruct, matStruct.clone());
    mesh.position.copy(pos);
    mesh.userData = { axis:i, type:'struct', name: STRUCT8[k8] };
    scene.add(mesh); nodes.push(mesh);
  }
  for(let i=0;i<16;i++){
    const mesh = new THREE.Mesh(geoEco, matEco.clone());
    mesh.position.copy(ecoPositions[i]);
    mesh.userData = { axis:i, type:'eco', name: ECO16[i] };
    scene.add(mesh); nodes.push(mesh);
  }
  for(let i=0;i<16;i++){
    const mesh = new THREE.Mesh(geoBadge, matBadge.clone());
    mesh.position.copy(badgePositions[i]);
    mesh.userData = { axis:i, type:'badge', name: ECO16[i] + "·徽章" };
    scene.add(mesh); nodes.push(mesh);
  }

  function makeLink(p1, p2, colorHex){
    const geo = new THREE.BufferGeometry().setFromPoints([p1, p2]);
    const mat = new THREE.LineBasicMaterial({ color: colorHex, transparent:true, opacity: 0.5 });
    const line = new THREE.Line(geo, mat);
    return line;
  }
  for(let i=0;i<16;i++){
    const sp = structPositions[i]; if(!sp) continue;
    const ep = ecoPositions[i];
    const line = makeLink(sp, ep, 0x6c8cff);
    line.userData = { axis:i, kind:'SE' };
    scene.add(line); edges.push(line);
  }
  for(let i=0;i<16;i++){
    const ep = ecoPositions[i];
    const bp = badgePositions[i];
    const line = makeLink(ep, bp, 0x34d399);
    line.userData = { axis:i, kind:'EB' };
    scene.add(line); edges.push(line);
  }

  const gridGeo = new THREE.SphereGeometry(R_BADGE+6, 32, 32);
  const gridMat = new THREE.MeshBasicMaterial({ color:0x233066, wireframe:true, transparent:true, opacity:0.08 });
  const gridMesh = new THREE.Mesh(gridGeo, gridMat); scene.add(gridMesh);

  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();
  const tooltip = document.getElementById('tooltip');

  function setTooltip(x, y, text){
    tooltip.style.left = x + "px";
    tooltip.style.top = y + "px";
    tooltip.textContent = text;
    tooltip.style.opacity = 1;
  }
  function hideTooltip(){ tooltip.style.opacity = 0; }

  let lastAxisHighlighted = null;
  let lockedAxis = null;

  function highlightAxis(axis, on){
    edges.forEach(line => {
      if(line.userData.axis === axis){
        const m = line.material;
        if(line.userData.kind === 'SE'){
          m.color.set(on ? 0x9db4ff : 0x6c8cff);
          m.opacity = on ? 1.0 : 0.5;
        }else{
          m.color.set(on ? 0x62e0b6 : 0x34d399);
          m.opacity = on ? 1.0 : 0.5;
        }
      }else if(on){
        line.material.opacity = 0.12;
      }else{
        line.material.opacity = 0.5;
      }
    });
    nodes.forEach(n => {
      if(n.userData.axis === axis){
        n.scale.set(1.35,1.35,1.35);
        if(n.material.emissive) n.material.emissiveIntensity = 0.9;
      }else{
        n.scale.set(1,1,1);
        if(n.material.emissive) n.material.emissiveIntensity = 0.4;
      }
    });
    lastAxisHighlighted = on ? axis : null;
  }

  function onPointerMove(ev){
    if(lockedAxis!=null) return;
    const rect = renderer.domElement.getBoundingClientRect();
    mouse.x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((ev.clientY - rect.top) / rect.height) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(nodes, false);
    if(intersects.length){
      const obj = intersects[0].object;
      highlightAxis(obj.userData.axis, true);
      setTooltip(ev.clientX, ev.clientY, obj.userData.type + " · " + obj.userData.name);
    }else{
      highlightAxis(lastAxisHighlighted, false);
      hideTooltip();
    }
  }
  renderer.domElement.addEventListener('pointermove', onPointerMove);

  renderer.domElement.addEventListener('click', (ev)=>{
    const rect = renderer.domElement.getBoundingClientRect();
    mouse.x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
    mouse.y = -((ev.clientY - rect.top) / rect.height) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(nodes, false);
    if(intersects.length){
      const obj = intersects[0].object;
      lockedAxis = (lockedAxis===obj.userData.axis) ? null : obj.userData.axis;
      highlightAxis(lockedAxis, !!lockedAxis);
    }else{
      lockedAxis = null;
      highlightAxis(lastAxisHighlighted, false);
    }
  });

  document.getElementById('autoRotate').addEventListener('change', (e)=>{
    controls.autoRotate = e.target.checked;
  });
  document.getElementById('showLinks').addEventListener('change', (e)=>{
    const vis = e.target.checked;
    edges.forEach(line => line.visible = vis);
  });

  window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  const clock = new THREE.Clock();
  function pulseNodes(t){
    const s = 1 + Math.sin(t*1.6)*0.03;
    nodes.forEach(n => {
      if(lockedAxis!=null && n.userData.axis!==lockedAxis) return;
      n.scale.setScalar(s);
    });
  }

  function animate(){
    const t = clock.getElapsedTime();
    controls.update();
    stars.rotation.y += 0.0006;
    gridMesh.rotation.y += 0.0004;
    pulseNodes(t);
    renderer.render(scene, camera);
    requestAnimationFrame(animate);
  }
  animate();
})();
</script>
</body>
</html>
