<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <title>åŒå›¾å½¢å åŠ ä¸åˆ‡æ¢</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body { background:#f0f2f5; margin:0; padding:10px; }
    .controls { margin-bottom:12px; }
    button { margin-right:8px; padding:6px 14px; border:none;
             background:#007bff; color:#fff; border-radius:6px; cursor:pointer; }
    button:hover { background:#0056b3; }
    .chart-container { position:relative; }
    .chart { position:absolute; top:0; left:0; width:100%; }
  </style>
</head>
<body>
  <div class="controls">
    <button onclick="toggleChart('chart1')">æ˜¾ç¤º/éšè— äººæ ¼èŠ±ç“£åŒç¯å›¾</button>
    <button onclick="toggleChart('chart2')">æ˜¾ç¤º/éšè— å››æ¶²è´¨èŠ±ç“£æ¨¡å‹</button>
  </div>

  <div class="chart-container">
    <!-- Chart1: houdonghua -->
    <div id="chart1" class="chart">
      <!-- ç›´æ¥ç²˜è´´ houdonghua.txt çš„å†…å®¹ -->
      <!-- ========== äººæ ¼èŠ±ç“£åŒç¯å›¾ï¼ˆæŸ”å’ŒåŠ¨ç”»ç‰ˆï¼‰ ========== -->
      <div class="wrap">
        <header><h1>ğŸŒ¸ äººæ ¼èŠ±ç“£åŒç¯å›¾ï¼ˆæ…¢é€ŸæŸ”å’ŒåŠ¨ç”» + é¿è®© + æœå†»å›å¼¹ï¼‰</h1></header>
        <svg id="stage1" viewBox="0 0 1800 1200">
          <defs>
            <radialGradient id="bgGradient" cx="50%" cy="50%" r="70%">
              <stop offset="0%" stop-color="#ffd6e8" stop-opacity="0.6"/>
              <stop offset="50%" stop-color="#d6eaff" stop-opacity="0.4"/>
              <stop offset="100%" stop-color="#ffffff" stop-opacity="0"/>
            </radialGradient>
          </defs>
          <rect width="100%" height="100%" fill="url(#bgGradient)" opacity="0.35"/>
          <g id="flower"></g>
        </svg>
        <div class="hint">
          âœ… å†…ç¯ä¸»æ ‡ç­¾ï¼›âœ… å¤–ç¯å­æ ‡ç­¾å‡åŒ€åˆ†å¸ƒï¼›âœ… å­æ ‡ç­¾æ…¢é€Ÿæµ®åŠ¨ï¼›âœ… æŸ”å’Œé¿è®©ï¼›âœ… æœå†»å›å¼¹ã€‚
        </div>
      </div>

      <script>
      /* ======= houdonghua.txt çš„è„šæœ¬ï¼Œæ”¹äº†ä¸€ç‚¹ç‚¹é¿å… ID å†²çª ======= */
      (function(){
        const W=1800,H=1200,cx=W/2,cy=H/2;
        const coreRingR=300, outerRingR=540;

        const svg=d3.select("#stage1");
        const gFlower=svg.select("#flower");
        const gNodes=gFlower.append("g"), gLabels=gFlower.append("g");

        const modules={
          "äººæ ¼ç±»å‹æ ‡ç­¾":["ç±»å‹è¯†åˆ«ç²¾åº¦ï¼ˆ72%ï¼‰","æƒ…ç»ªé©±åŠ¨å€¾å‘ï¼ˆ63%ï¼‰","å†³ç­–é€Ÿåº¦åå¥½ï¼ˆ0.82sï¼‰","æ„ŸçŸ¥æ•é”åº¦ï¼ˆ68%ï¼‰","ç›´è§‰ä¿¡å·å¼ºåº¦ï¼ˆ74%ï¼‰","ç†æ€§-æ„Ÿæ€§å¹³è¡¡ï¼ˆ0.58ï¼‰","é£é™©å®¹å¿æ°´å¹³ï¼ˆ61%ï¼‰","è¡Œä¸ºä¸€è‡´æ€§ï¼ˆ69%ï¼‰"],
          "äººæ ¼ç»“æ„":["å†…å‘/å¤–å‘æ¯”ä¾‹ï¼ˆ46%ï¼‰","æƒ…ç»ªç¨³å®šç»´åº¦ï¼ˆ64%ï¼‰","å†²åŠ¨æ§åˆ¶èƒ½åŠ›ï¼ˆ57%ï¼‰","è‡ªæˆ‘è§‰å¯Ÿæ°´å¹³ï¼ˆ71%ï¼‰","æ„å¿—åŠ›å‚¨å¤‡ï¼ˆ62%ï¼‰","è¡Œä¸ºçµæ´»åº¦ï¼ˆ66%ï¼‰","ä»·å€¼è§‚å†…èšæ€§ï¼ˆ59%ï¼‰","é€‚åº”-æŠ—æ‹’åŒºé—´ï¼ˆ41%ï¼‰"],
          "æ ¸å¿ƒç‰¹è´¨æ ‡ç­¾":["å¼€æ”¾æ€§æŒ‡æ•°ï¼ˆ72%ï¼‰","å°½è´£æ€§æ°´å¹³ï¼ˆ69%ï¼‰","å¤–å‘æ€§å¾—åˆ†ï¼ˆ63%ï¼‰","å®œäººæ€§æŒ‡æ ‡ï¼ˆ77%ï¼‰","ç¥ç»è´¨é£é™©ï¼ˆ55%ï¼‰","é€‚åº”æ€§äººæ ¼ç‰¹å¾ï¼ˆ65%ï¼‰","æƒ…å¢ƒä¾èµ–å‹è¡Œä¸ºæ¨¡å¼ï¼ˆ70%ï¼‰","è‡ªå¾‹ç»´æŒåŠ›ï¼ˆ62%ï¼‰"],
          "ç¯å¢ƒé€‚åº”åŠ›":["å‹åŠ›æ¢å¤é€Ÿåº¦ï¼ˆ68%ï¼‰","å˜åŒ–åº”å¯¹èƒ½åŠ›ï¼ˆ61%ï¼‰","èµ„æºæ•´åˆæ•ˆç‡ï¼ˆ72%ï¼‰","ç¤¾ä¼šé€‚åº”æŒ‡æ•°ï¼ˆ74%ï¼‰","é€»è¾‘é—­ç¯èƒ½åŠ›ï¼ˆ74.5%ï¼‰","ç¯å¢ƒæ‰«æç²¾åº¦ï¼ˆ66%ï¼‰","ä¹ æƒ¯é‡å»ºé€Ÿåº¦ï¼ˆ57%ï¼‰","æŒç»­ä¼˜åŒ–å€¾å‘ï¼ˆ63%ï¼‰"],
          "æ½œåœ¨ç†µå¢è­¦å‘Š":["æƒ…ç»ªå¤±è¡¡é£é™©ï¼ˆ58%ï¼‰","è®¤çŸ¥åå·®é¢‘ç‡ï¼ˆ47%ï¼‰","è¡Œä¸ºåƒµåŒ–ç¨‹åº¦ï¼ˆ62%ï¼‰","å†²çªå‡çº§æ¦‚ç‡ï¼ˆ44%ï¼‰","ç›®æ ‡æ‰§è¡Œé“¾æ¡è„†å¼±ï¼ˆ71%ï¼‰","æ³¨æ„åŠ›åˆ†æ•£æ°´å¹³ï¼ˆ55%ï¼‰","åŠ¨æœºè¡°å‡æ›²çº¿ï¼ˆ52%ï¼‰","è‡ªæˆ‘çŸ›ç›¾é¢‘ç‡ï¼ˆ48%ï¼‰"],
          "ä¼˜åŒ–ç­–ç•¥":["æƒ…ç»ªè°ƒèŠ‚è·¯å¾„ï¼ˆ64%ï¼‰","è®¤çŸ¥é‡æ„æ•ˆèƒ½ï¼ˆ67%ï¼‰","è¡Œä¸ºè®­ç»ƒåé¦ˆç‡ï¼ˆ72%ï¼‰","å…³ç³»ä¿®å¤æŒ‡æ•°ï¼ˆ63%ï¼‰","æƒ…æ„Ÿè¡¨è¾¾ç¼–ç æ•ˆç‡ï¼ˆ59.6%ï¼‰","æ³¨æ„åŠ›ç®¡ç†ç³»ç»Ÿå‡çº§ï¼ˆ44.5%ï¼‰","å­¦ä¹ è¿ç§»æ•ˆç‡ï¼ˆ62%ï¼‰","è‡ªæˆ‘æ¿€åŠ±æœºåˆ¶ï¼ˆ66%ï¼‰"],
          "å‘å±•æ½œåŠ›æ ‡ç­¾":["åˆ›é€ åŠ›æ½œèƒ½ï¼ˆ68%ï¼‰","é¢†å¯¼åŠ›æˆé•¿å€¼ï¼ˆ71%ï¼‰","å…±æƒ…åŠ›æ‹“å±•åº¦ï¼ˆ64%ï¼‰","æŠ—å‹èƒ½åŠ›æå‡æ›²çº¿ï¼ˆ69%ï¼‰","ç»¼åˆå‘å±•æ½œåŠ›ï¼ˆâ˜…â˜…â˜…â˜†â˜†ï¼‰","æ¸è¿›å¼æˆé•¿è·¯å¾„ï¼ˆ60%ï¼‰","çŸ¥è¯†æ•´åˆæ·±åº¦ï¼ˆ63%ï¼‰","å­¦ä¹ é€Ÿåº¦å˜åŒ–ç‡ï¼ˆ57%ï¼‰"],
          "å…³ç³»æ¨¡å¼æ ‡ç­¾":["ä¾èµ–å‹å…³ç³»å¼ºåº¦ï¼ˆ61%ï¼‰","ç‹¬ç«‹å‹å…³ç³»ç»´åº¦ï¼ˆ59%ï¼‰","åˆä½œå‹å…³ç³»æ¨¡å¼ï¼ˆ67%ï¼‰","å¯¹æŠ—å‹å…³ç³»å€¾å‘ï¼ˆ44%ï¼‰","å¹³è¡¡å‹å…³ç³»æ¨¡å¼ï¼ˆ55%ï¼‰","æƒ…å¢ƒé€‚åº”å‹äº’åŠ¨é£æ ¼ï¼ˆ65%ï¼‰","æ²Ÿé€šé€æ˜åº¦ï¼ˆ62%ï¼‰","ä¿¡ä»»æ„å»ºé€Ÿåº¦ï¼ˆ71%ï¼‰"]
        };

        const colors=["#ff7f50","#1e90ff","#9370db","#3cb371","#ff69b4","#ffa500","#20b2aa","#708090"];
        const moduleOrder=Object.keys(modules);
        const angleStep=(2*Math.PI)/moduleOrder.length;

        function measureTextWidth(t,fs=11){
          const temp=svg.append("text").style("font-size",fs+"px").attr("visibility","hidden").text(t);
          const w=temp.node().getBBox().width; temp.remove(); return w;
        }
        function ellipseSizeForText(t,fs=11,px=16,py=10){
          const w=measureTextWidth(t,fs); return {rx:w/2+px, ry:fs*0.85+py};
        }

        const anchors={},nodes=[];
        moduleOrder.forEach((m,i)=>{
          anchors[m]={x:cx+Math.cos(i*angleStep)*coreRingR,y:cy+Math.sin(i*angleStep)*coreRingR,angle:i*angleStep};
        });

        moduleOrder.forEach((m,mi)=>{
          const a=anchors[m],c=colors[mi%colors.length];
          const baseCore=ellipseSizeForText(m,13,18,12);
          nodes.push({id:`core-${mi}`,kind:"core",key:m,name:m,color:c,x:a.x,y:a.y,
                      rx:Math.max(100,baseCore.rx),ry:Math.max(60,baseCore.ry)});
        });

        const subs=[];
        moduleOrder.forEach((m,mi)=>{
          const sub=modules[m],c=colors[mi%colors.length];
          sub.forEach((txt,i)=>subs.push({m,mi,c,txt}));
        });

        subs.forEach((s,i)=>{
          const th=(i/subs.length)*2*Math.PI;
          const posX=cx+Math.cos(th)*outerRingR;
          const posY=cy+Math.sin(th)*outerRingR;
          const sz=ellipseSizeForText(s.txt,11,16,10);
          nodes.push({
            id:`tag-${s.mi}-${i}`,kind:"tag",key:s.m,name:s.txt,color:s.c,
            baseTheta:th,x:posX,y:posY,
            rx:sz.rx,ry:sz.ry,rx0:sz.rx,ry0:sz.ry,
            active:false,floatPhase:Math.random()*6.28
          });
        });

        const nodeSel=gNodes.selectAll("ellipse").data(nodes).enter().append("ellipse")
          .attr("class",d=>`petal ${d.kind}`)
          .attr("fill",d=>d.kind==="core"?d.color:"transparent")
          .attr("stroke",d=>d.kind==="core"?"none":d.color)
          .attr("stroke-width",d=>d.kind==="core"?0:2)
          .on("click",function(e,d){
            if(d.kind!=="tag")return;
            d.active=!d.active;
            d.rx=d.active?d.rx0*1.2:d.rx0;
            d.ry=d.active?d.ry0*1.2:d.ry0;
            d3.select(this).attr("fill",d.active?d.color:"transparent").attr("stroke-width",d.active?0:2);
          });

        const labelSel=gLabels.selectAll("text").data(nodes).enter().append("text")
          .attr("class",d=>d.kind==="core"?"label core-label":"label").text(d=>d.name);

        d3.timer(()=>{
          nodes.forEach(n=>{
            if(n.kind==="tag"){
              n.floatPhase += 0.005;
              const radialOffset=Math.sin(n.floatPhase)*4;
              const tangentialOffset=Math.cos(n.floatPhase*0.7)*2;
              const r=outerRingR+radialOffset;
              const targetX=cx+Math.cos(n.baseTheta)*r+Math.cos(n.baseTheta+Math.PI/2)*tangentialOffset;
              const targetY=cy+Math.sin(n.baseTheta)*r+Math.sin(n.baseTheta+Math.PI/2)*tangentialOffset;
              n.x += (targetX-n.x)*0.05;
              n.y += (targetY-n.y)*0.05;
            }
          });

          for(let i=0;i<nodes.length;i++){
            for(let j=i+1;j<nodes.length;j++){
              const a=nodes[i],b=nodes[j];
              if(a.kind==="core"||b.kind==="core") continue;
              const dx=a.x-b.x,dy=a.y-b.y,dist=Math.sqrt(dx*dx+dy*dy);
              const minDist=Math.max(a.rx,a.ry)+Math.max(b.rx,b.ry)+6;
              if(dist<minDist && dist>0){
                const push=(minDist-dist)*0.1;
                const ux=dx/dist,uy=dy/dist;
                a.x+=ux*push; a.y+=uy*push;
                b.x-=ux*push; b.y-=uy*push;
              }
            }
          }

          nodes.forEach(n=>{
            if(n.kind==="tag" && !n.active){
              n.rx+=(n.rx0-n.rx)*0.05;
              n.ry+=(n.ry0-n.ry)*0.05;
            }
          });

          ticked();
        });

        function ticked(){
          nodeSel.attr("cx",d=>d.x).attr("cy",d=>d.y).attr("rx",d=>d.rx).attr("ry",d=>d.ry);
          labelSel.attr("x",d=>d.x).attr("y",d=>d.y);
        }
        ticked();
      })();
      </script>
    </div>

    <!-- Chart2: donghua -->
    <div id="chart2" class="chart">
      <!-- ç›´æ¥ç²˜è´´ donghua.txt çš„å†…å®¹ -->
      <!-- ========== å››æ¶²è´¨èŠ±ç“£åŠ›å­¦æ¨¡å‹ï¼ˆéšé£æ‘‡æ›³ç‰ˆï¼‰ ========== -->
      <div class="wrap">
        <header><h1>ğŸŒ¸ å››æ¶²è´¨èŠ±ç“£åŠ›å­¦æ¨¡å‹ï¼ˆéšé£æ‘‡æ›³ç‰ˆï¼‰</h1></header>
        <svg id="stage2" viewBox="0 0 1120 820"></svg>
        <div class="hint">
          ç‚¹å‡»å­æ ‡ç­¾åˆ‡æ¢å®å¿ƒ/ç©ºå¿ƒï¼›å­æ ‡ç­¾æŒç»­æ¼‚æµ®+å‘¼å¸ï¼›ä¸»èŠ±ç“£éšæ¿€æ´»æ•°é‡ç¼©æ”¾å¹¶è½»å¾®æ‘‡æ‘†ï¼›æ•´æœµèŠ±ä¼šéšé£å·¦å³æ‘†åŠ¨ã€‚
        </div>
      </div>

      <script>
      /* ======= donghua.txt çš„è„šæœ¬ï¼Œæ”¹äº†ä¸€ç‚¹ç‚¹é¿å… ID å†²çª ======= */
      (function(){
        const temperamentGroups = {
          sanguine:   ["ç¤¾äº¤","æ´»æ³¼","æƒ…ç»ªæ³¢åŠ¨","ç²¾åŠ›æ—ºç››","ä¹è§‚","å¥è°ˆ","éšå’Œ","å¯»æ±‚åˆºæ¿€"],
          choleric:   ["æœæ–­","é¢†å¯¼åŠ›","é‡å¿ƒ","è‡ªä¿¡","ç«äº‰æ€§","ç›®æ ‡å¯¼å‘","æ€¥èº","æ”¯é…æ€§"],
          melancholic:["æ•æ„Ÿ","æ¸©æŸ”","å°é—­","å…±æƒ…","å®Œç¾ä¸»ä¹‰","æ·±æ€ç†Ÿè™‘","æ‚²è§‚","ç†æƒ³ä¸»ä¹‰"],
          phlegmatic: ["å†·é™","è€å¿ƒ","ç¨³å®š","å¯é ","å¹³å’Œ","è§„å¾‹","é¿å…å†²çª","åŠ¡å®","ç‰©è´¨ä¸»å¯¼","è¢«åŠ¨","å†…æ•›","éé»‘å³ç™½"]
        };
        const names  = { sanguine:"å¤šè¡€è´¨", choleric:"èƒ†æ±è´¨", melancholic:"æŠ‘éƒè´¨", phlegmatic:"ç²˜æ¶²è´¨" };
        const colors = { sanguine:"#ff7f50", choleric:"#1e90ff", melancholic:"#9370db", phlegmatic:"#3cb371" };

        const svg = d3.select("#stage2");
        const W = 1120, H = 820, cx = W/2, cy = H/2;
        const coreRadius = 210;
        const anchors = {
          melancholic: { x: cx, y: cy - coreRadius, angle: -90 },
          phlegmatic:  { x: cx, y: cy + coreRadius, angle:  90 },
          sanguine:    { x: cx - coreRadius, y: cy, angle:  180 },
          choleric:    { x: cx + coreRadius, y: cy, angle:  0 }
        };

        const nodes = [];
        const links = [];

        Object.keys(anchors).forEach(k=>{
          const a = anchors[k];
          nodes.push({
            id: "core-"+k, kind:"core", key:k, name:names[k],
            x:a.x, y:a.y, vx:0, vy:0,
            baseRx: 95, baseRy: 64, rx:95, ry:64,
            targetRx:95, targetRy:64,
            color: colors[k], fixed:true, swayPhase: Math.random()*Math.PI*2
          });
        });

        const orbitR = 160, childRx = 36, childRy = 18;
        Object.keys(temperamentGroups).forEach(k=>{
          const list = temperamentGroups[k];
          const step = Math.PI/(list.length+1);
          list.forEach((tag,i)=>{
            const theta = (anchors[k].angle-90)*Math.PI/180 + (i+1)*step;
            const x = anchors[k].x + Math.cos(theta)*orbitR;
            const y = anchors[k].y + Math.sin(theta)*orbitR;
            nodes.push({
              id:`tag-${k}-${i}`, kind:"tag", key:k, name:tag,
              x, y, vx:0, vy:0,
              rx:childRx, ry:childRy, rx0:childRx, ry0:childRy,
              targetRx:childRx, targetRy:childRy,
              thetaBase: theta, phase: Math.random()*Math.PI*2, speed: 0.001 + Math.random()*0.001,
              color: colors[k], active:false, breathPhase: Math.random()*Math.PI*2
            });
            links.push({ source:"core-"+k, target:`tag-${k}-${i}` });
          });
        });

        const gFlower = svg.append("g");
        const gLinks  = gFlower.append("g").attr("stroke","#eee").attr("stroke-width",1.2).attr("opacity",0.6);
        const gNodes  = gFlower.append("g");
        const gLabels = gFlower.append("g");

        const linkSel = gLinks.selectAll("line").data(links).enter().append("line");

        const nodeSel = gNodes.selectAll("ellipse").data(nodes).enter().append("ellipse")
          .attr("class","petal")
          .attr("fill", d => d.kind==="core" ? d.color : "transparent")
          .attr("stroke", d => d.kind==="core" ? "none" : d.color)
          .attr("stroke-width", d => d.kind==="core" ? 0 : 2)
          .attr("opacity", 0.95)
          .on("click", function(e,d){
            if(d.kind!=="tag") return;
            d.active = !d.active;
            d.rx0 = d.active ? childRx+8 : childRx;
            d.ry0 = d.active ? childRy+6 : childRy;
            d.targetRx = d.rx0;
            d.targetRy = d.ry0;
            d3.select(this)
              .attr("fill", d.active ? d.color : "transparent")
              .attr("stroke-width", d.active ? 0 : 2);
            updateCoreSizes();
            refreshCollide();
          });

        const labelSel = gLabels.selectAll("text").data(nodes).enter().append("text")
          .attr("class","label")
          .style("font-size", d => d.kind==="core" ? "14px" : "12px")
          .text(d => d.name);

        function updateCoreSizes(){
          const counts = { sanguine:0, choleric:0, melancholic:0, phlegmatic:0 };
          nodes.forEach(n => { if(n.kind==="tag" && n.active) counts[n.key]++; });
          nodes.forEach(n=>{
            if(n.kind==="core"){
              const c = counts[n.key];
              n.targetRx = n.baseRx + c*12;
              n.targetRy = n.baseRy + c*8;
            }
          });
        }

        function driftTarget(n){
          if(n.kind!=="tag") return {x:n.x,y:n.y};
          n.phase += n.speed;
          const theta = n.thetaBase + Math.sin(n.phase)*0.28;
          const r = orbitR + Math.cos(n.phase*0.8)*12;
          const a = anchors[n.key];
          return { x: a.x + Math.cos(theta)*r, y: a.y + Math.sin(theta)*r };
        }

        function applyBreath(n){
          if(n.kind!=="tag") return;
          n.breathPhase += 0.01;
          const scale = 1 + 0.08*Math.sin(n.breathPhase);
          n.targetRx = n.rx0 * scale;
          n.targetRy = n.ry0 * scale;
        }

        function applySqueeze(){
          for(let i=0;i<nodes.length;i++){
            for(let j=i+1;j<nodes.length;j++){
              const a=nodes[i], b=nodes[j];
              const dx=b.x-a.x, dy=b.y-a.y;
              const dist=Math.hypot(dx,dy);
              const minDist=(Math.max(a.rx,a.ry)+Math.max(b.rx,b.ry))*0.95;
              if(dist<minDist){
                const overlap=(minDist-dist)/minDist;
                if(a.kind!=="core"){
                  a.targetRx = a.rx0*(1-overlap*0.15);
                  a.targetRy = a.ry0*(1-overlap*0.15);
                }
                if(b.kind!=="core"){
                  b.targetRx = b.rx0*(1-overlap*0.15);
                  b.targetRy = b.ry0*(1-overlap*0.15);
                }
              }
            }
          }
        }

        function lerp(a,b,t){ return a+(b-a)*t; }
        function updateSizes(){
          nodes.forEach(n=>{
            n.rx = lerp(n.rx, n.targetRx, 0.1);
            n.ry = lerp(n.ry, n.targetRy, 0.1);
          });
        }

        const forceToAnchor = () => {
          nodes.forEach(n=>{
            if(n.kind==="core"){
              const a = anchors[n.key];
              n.vx += (a.x - n.x)*0.15;
              n.vy += (a.y - n.y)*0.15;
            } else {
              const t = driftTarget(n);
              n.vx += (t.x - n.x)*0.02;
              n.vy += (t.y - n.y)*0.02;
            }
          });
        };
        let collide = d3.forceCollide().radius(d => Math.max(d.rx,d.ry)*0.95).iterations(1);
        const charge = d3.forceManyBody().strength(d => d.kind==="core"? -60 : -15);

        const sim = d3.forceSimulation(nodes)
          .alpha(0.9)
          .alphaDecay(0.02)
          .velocityDecay(0.25)
          .force("charge", charge)
          .force("collide", collide)
          .on("tick", ticked);

        function refreshCollide(){
          collide.radius(d => Math.max(d.rx,d.ry)*0.95);
          sim.alpha(0.6).restart();
        }

        let globalPhase = 0;
        function applyWindyMotion(){
          globalPhase += 0.003;
          const swayX = Math.sin(globalPhase) * 20;
          const swayY = Math.cos(globalPhase*0.7) * 10;
          gFlower.attr("transform", `translate(${swayX},${swayY})`);
        }

        function ticked(){
          forceToAnchor();
          nodes.forEach(n=>applyBreath(n));
          applySqueeze();
          updateSizes();
          nodeSel.attr("cx", d=>d.x).attr("cy", d=>d.y).attr("rx", d=>d.rx).attr("ry", d=>d.ry);
          labelSel.attr("x", d=>d.x).attr("y", d=>d.y+4);
          linkSel
            .attr("x1", d=>getNode(d.source).x).attr("y1", d=>getNode(d.source).y)
            .attr("x2", d=>getNode(d.target).x).attr("y2", d=>getNode(d.target).y);
          applyWindyMotion();
        }

        function getNode(idOrObj){ return (typeof idOrObj==="string") ? nodes.find(n=>n.id===idOrObj) : idOrObj; }

        updateCoreSizes();
      })();
      </script>
    </div>
  </div>

  <script>
    function toggleChart(id){
      const el=document.getElementById(id);
      el.style.display = (el.style.display==="none") ? "block" : "none";
    }
  </script>
</body>
</html>
